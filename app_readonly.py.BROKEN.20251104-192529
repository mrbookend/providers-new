# === ANCHOR: IMPORTS (start) ===
from __future__ import annotations

# stdlib
import os
import re
import unicodedata

# third-party
import pandas as pd
import sqlalchemy as sa
import streamlit as st
from st_aggrid import GridOptionsBuilder, JsCode

# local
from export_utils import ensure_phone_string, to_xlsx_bytes

# === ANCHOR: IMPORTS (end) ===


# === ANCHOR: PAGE CONFIG (start) ===
st.set_page_config(page_title="Providers â€” Read-Only", page_icon="ðŸ“˜", layout="wide")
# === ANCHOR: PAGE CONFIG (end) ===


# === ANCHOR: WHOLE-WORD WRAP (start) ===
# Import the real AgGrid under a private name; wrapper defined below.
try:
    from st_aggrid import AgGrid as _AgGrid
except Exception:
    _AgGrid = None

# CSS merged at call-time (keeps words intact; long tokens still break)
DEFAULT_WRAP_CSS = {
    ".ag-theme-streamlit .ag-cell": {
        "white-space": "normal !important",
        "word-break": "keep-all !important",
        "overflow-wrap": "anywhere !important",
        "hyphens": "auto !important",
        "line-height": "1.25 !important",
    },
    ".ag-theme-quartz .ag-cell": {
        "white-space": "normal !important",
        "word-break": "keep-all !important",
        "overflow-wrap": "anywhere !important",
        "hyphens": "auto !important",
        "line-height": "1.25 !important",
    },
}

JS_RESET_ROW_HEIGHTS = JsCode(
    """
function(params) {
  const api = params.api;
  if (api && api.resetRowHeights) {
    api.resetRowHeights();
    setTimeout(function(){ try { api.resetRowHeights(); } catch(e){} }, 0);
  }
}
"""
)

if _AgGrid is not None:

    def AgGrid(df, **kwargs):
        go = dict(kwargs.pop("gridOptions", {}) or {})
        # Defaults: whole-word wrap + auto-height rows
        dcol = dict(go.get("defaultColDef", {}) or {})
        dcol.setdefault("wrapText", True)
        dcol.setdefault("autoHeight", True)
        go["defaultColDef"] = dcol
        go.setdefault("domLayout", "autoHeight")
        # Recompute heights on common events
        go.setdefault("onFirstDataRendered", JS_RESET_ROW_HEIGHTS)
        go.setdefault("onFilterChanged", JS_RESET_ROW_HEIGHTS)
        go.setdefault("onColumnResized", JS_RESET_ROW_HEIGHTS)

        # Merge caller CSS with our wrapper CSS
        user_css = dict(kwargs.pop("custom_css", {}) or {})
        merged_css = dict(DEFAULT_WRAP_CSS)
        merged_css.update(user_css)
        kwargs["custom_css"] = merged_css

        kwargs.setdefault("fit_columns_on_grid_load", False)
        kwargs.setdefault("allow_unsafe_jscode", True)

        kwargs["gridOptions"] = go
        return _AgGrid(df, **kwargs)
# === ANCHOR: WHOLE-WORD WRAP (end) ===


# === ANCHOR: CONSTANTS (start) ===
DB_PATH = os.environ.get("PROVIDERS_DB", "providers.db")

# Secrets defaults
SECRETS = st.secrets if hasattr(st, "secrets") else {}
PREFS = {
    "order": SECRETS.get(
        "BROWSE_ORDER",
        [
            "category",
            "service",
            "business_name",
            "address",
            "contact_name",
            "phone",
            "website",
            "email",
            "notes",
        ],
    ),
    "hide": set(
        SECRETS.get(
            "HIDE_COLUMNS",
            [
                "id",
                "created_at",
                "updated_at",
                "ckw_locked",
                "ckw_version",
                "ckw_manual_extra",
                "keywords",
                "ckw",
                "computed_keywords",
                "city",
                "state",
                "zip",
                "phone_fmt",
            ],
        )
    ),
    "use_aggrid": int(SECRETS.get("READONLY_USE_AGGRID", 1)),
    "always_reset": int(SECRETS.get("READONLY_ALWAYS_RESET", 1)),
    "col_widths": (
        SECRETS.get("DEBUG_READONLY_WIDTHS", 0) and SECRETS.get("COLUMN_WIDTHS_PX_ADMIN", {})
    )
    or {},
    "page_size": int(SECRETS.get("READONLY_PAGE_SIZE", 0)),  # 0 = auto/single
    "single_page": int(SECRETS.get("READONLY_SINGLE_PAGE", 0)),  # 1=all rows
    "_header_px": int(SECRETS.get("READONLY_HEADER_PX", 0)),
    "grid_h": int(SECRETS.get("READONLY_GRID_HEIGHT", 420)),
    "font_px": int(SECRETS.get("READONLY_FONT_PX", 14)),
}
# Always hide raw keyword columns in UI (still searchable)
PREFS["hide"] = set(PREFS["hide"]).union({"computed_keywords", "keywords"})
# === ANCHOR: CONSTANTS (end) ===


# === ANCHOR: ENGINE (start) ===
ENG = sa.create_engine(f"sqlite:///{DB_PATH}", pool_pre_ping=True)
# === ANCHOR: ENGINE (end) ===


# === ANCHOR: SEARCH LOGIC (start) ===
# Columns included in global search (displayed/hidden doesn't matter)
SEARCH_COLS = [
    "category",
    "service",
    "business_name",
    "address",
    "notes",
    "website",
    "email",
    "computed_keywords",
    "keywords",  # searchable; UI will hide them
]
PHONE_COL = "phone_fmt"  # digits-only; fallback to 'phone' if needed

# Scopes: cat:, svc:, name:, addr:, notes:, web:, email:, phone:, kw:, ckw:
_scopes = {
    "cat": "category",
    "svc": "service",
    "name": "business_name",
    "addr": "address",
    "notes": "notes",
    "web": "website",
    "email": "email",
    "phone": PHONE_COL,
    "kw": "computed_keywords",
    "ckw": "computed_keywords",
}


def _strip_accents(s: str) -> str:
    return "".join(ch for ch in unicodedata.normalize("NFKD", s) if not unicodedata.combining(ch))


def _digits(s: str) -> str:
    return re.sub(r"\D+", "", s or "")


def parse_query(q: str):
    """
    Returns list of tokens:
      {"neg":bool, "scope":str|None, "text":str, "is_prefix":bool, "is_phrase":bool}
    Semantics:
      - AND across tokens (case-insensitive).
      - Quoted phrases stay together: "water heater".
      - Prefix if token ends with * (heat*); otherwise substring.
      - Negation via leading '-' (e.g., -leak).
      - Column scopes: cat:, svc:, name:, addr:, notes:, web:, email:, phone:, kw:, ckw:
    """
    q = (q or "").strip()
    if not q:
        return []
    phrases = re.findall(r'"([^"]+)"', q)
    q_wo = re.sub(r'"[^"]+"', " ", q)
    parts = [p for p in re.split(r"\s+", q_wo) if p] + [f'"{p}"' for p in phrases]

    tokens = []
    for raw in parts:
        neg = raw.startswith("-")
        t = raw[1:] if neg else raw
        scope = None
        m = re.match(r"(?i)^(cat|svc|name|addr|notes|web|email|phone|kw|ckw):(.*)$", t)
        if m:
            scope, t = m.group(1).lower(), m.group(2)

        is_phrase = t.startswith('"') and t.endswith('"')
        if is_phrase:
            t = t[1:-1]

        is_prefix = t.endswith("*")
        if is_prefix:
            t = t[:-1]

        text = t.strip()
        if not text:
            continue

        tokens.append(
            {
                "neg": neg,
                "scope": _scopes.get(scope) if scope else None,
                "text": text,
                "is_prefix": is_prefix,
                "is_phrase": is_phrase,
            }
        )
    return tokens


def build_sql_where(tokens):
    """Return (sql, params) for SQLite WHERE semantics matching parse_query."""
    if not tokens:
        return "1=1", []
    clauses, params = [], []
    for tk in tokens:
        cols = [tk["scope"]] if tk["scope"] else SEARCH_COLS
        sub = []
        for c in cols:
            if c == PHONE_COL:
                pat = f"{_digits(tk['text'])}%" if tk["is_prefix"] else f"%{_digits(tk['text'])}%"
                if pat.strip("%") == "":
                    continue
                sub.append(f"REPLACE(REPLACE(REPLACE({PHONE_COL},'(',''),')',''),'-','') LIKE ?")
                params.append(pat)
            else:
                needle = tk["text"].lower()
                like = f"{needle}%" if tk["is_prefix"] else f"%{needle}%"
                sub.append(f"LOWER({c}) LIKE ?")
                params.append(like)
        if not sub:
            continue
        group = "(" + " OR ".join(sub) + ")"
        clauses.append(("NOT " if tk["neg"] else "") + group)
    return (" AND ".join(clauses) or "1=1"), params


def pandas_filter(df, tokens):
    """Same semantics in-memory on a pandas DataFrame."""
    if not tokens or df.empty:
        return df
    norm = {}
    for c in set(SEARCH_COLS):
        if c in df.columns:
            norm[c] = df[c].astype(str).map(_strip_accents).str.lower()
    if PHONE_COL in df.columns:
        norm[PHONE_COL] = df[PHONE_COL].astype(str).map(_digits)

    mask = pd.Series(True, index=df.index)
    for tk in tokens:
        cols = [tk["scope"]] if tk["scope"] else SEARCH_COLS
        col_masks = []
        for c in cols:
            if c not in norm:
                continue
            hay = norm[c]
            if c == PHONE_COL:
                n = _digits(tk["text"])
                if not n:
                    continue
                rgx = r"^" + re.escape(n) if tk["is_prefix"] else re.escape(n)
                col_masks.append(hay.str.contains(rgx, regex=True, na=False))
            else:
                needle = _strip_accents(tk["text"]).lower()
                if tk["is_prefix"]:
                    col_masks.append(
                        hay.str.contains(r"\b" + re.escape(needle), regex=True, na=False)
                    )
                else:
                    col_masks.append(hay.str.contains(re.escape(needle), regex=True, na=False))
        if not col_masks:
            continue
        grp = col_masks[0]
        for cm in col_masks[1:]:
            grp = grp | cm
        mask = mask & (~grp if tk["neg"] else grp)
    return df[mask]


# === ANCHOR: SEARCH LOGIC (end) ===


# === ANCHOR: DATA LOAD (start) ===
@st.cache_data(show_spinner=False)
def load_df(search_text: str) -> pd.DataFrame:
    """Load vendors with optional server-side filtering."""
    tokens = parse_query(search_text)
    where_sql, where_params = build_sql_where(tokens)
    sql = f"""
    SELECT *
    FROM vendors
    WHERE {where_sql}
    ORDER BY business_name COLLATE NOCASE ASC
    """
    with ENG.connect() as cx:
        return pd.read_sql_query(sa.text(sql), cx, params=where_params)


# === ANCHOR: DATA LOAD (end) ===


# === ANCHOR: PREFS & VIEW (start) ===
def _apply_readonly_prefs(df: pd.DataFrame):
    """Return (df2, view_cols, _hidden_cols, prefs) according to secrets and guards."""
    cols = list(df.columns)
    must_hide = set(PREFS["hide"])
    # view columns in preferred order, then any remaining visible ones
    seed = [c for c in PREFS["order"] if c in cols]
    visible_cols = [c for c in cols if c not in must_hide]
    view_cols = seed + [c for c in visible_cols if c not in set(seed)]
    return df, view_cols, must_hide, PREFS


# === ANCHOR: PREFS & VIEW (end) ===


# === ANCHOR: UI (start) ===
def _phone_fmt_py(val: str) -> str:
    try:
        return ensure_phone_string(val)
    except Exception:
        return val or ""


def main() -> None:
    st.title("Providers â€” Read-Only")

    # Search box
    with st.container():
        st.write("")
        q = st.text_input(
            "Search",
            value="",
            placeholder='AND across terms; "quoted phrase"; cat:, svc:, name:, addr:, phone:, notes:, web:, email:, kw:, ckw:; -negate; * = prefix',
        )

    df = load_df(q)
    df2, view_cols, _hidden_cols, prefs = _apply_readonly_prefs(df)
    df = df2

    # Build display frame and hide keyword columns (searchable but invisible)
    df_display = df[view_cols].copy()
    for _col in ("computed_keywords", "keywords"):
        if _col in df_display.columns:
            df_display.drop(columns=[_col], inplace=True)

    has_aggrid = _AgGrid is not None
    if not has_aggrid or not int(prefs.get("use_aggrid", 1)):
        st.dataframe(df_display, use_container_width=False, hide_index=True)
        return

    # GridOptions via builder
    gob = GridOptionsBuilder.from_dataframe(df_display)

    # Hide CKW/keywords defensively (even though we dropped them)
    for _col in ("computed_keywords", "keywords"):
        try:
            gob.configure_column(_col, hide=True, sortable=False, filter=False, suppressMenu=True)
        except Exception:
            pass

    # Phone formatter (if you keep a string phone column visible)
    _phone_fmt_js = JsCode(
        """
      function(params){
        if (!params.value) return "";
        const raw = String(params.value);
        return raw;
      }
    """
    )
    if "phone" in df_display.columns:
        gob.configure_column("phone", valueFormatter=_phone_fmt_js)

    # Width mapping (optional) from secrets
    try:
        widths = {
            str(k).strip().lower(): int(v) for k, v in dict(prefs.get("col_widths", {})).items()
        }
    except Exception:
        widths = {}
    gob.configure_default_column(suppressSizeToFit=True)
    gob.configure_grid_options(suppressAutoSize=True)
    for col in df_display.columns:
        lk = str(col).strip().lower()
        if lk in widths:
            try:
                gob.configure_column(col, width=int(widths[lk]))
            except Exception:
                pass

    # Selective explicit wrap (we also have defaults in wrapper)
    for _col in ("business_name", "address", "category", "service"):
        if _col in df_display.columns:
            gob.configure_column(_col, wrapText=True, autoHeight=True)

    # Layout & pagination
    page_size = int(prefs.get("page_size", 0))
    single_page = int(prefs.get("single_page", 0))
    _header_px = int(prefs.get("header_px", 0))
    grid_h = int(prefs.get("grid_h", 420))

    grid_opts: dict = {}
    if single_page:
        grid_opts["pagination"] = False
    elif page_size > 0:
        grid_opts["pagination"] = True
        grid_opts["paginationPageSize"] = page_size

    # Force re-instantiation when widths change / when always_reset=1
    always_reset = int(prefs.get("always_reset", 1))
    _nonce = st.session_state.get("__readonly_grid_nonce__", 0)
    if always_reset:
        _nonce += 1
        st.session_state["__readonly_grid_nonce__"] = _nonce

    opts = gob.build()
    opts.update(grid_opts)

    if single_page or page_size > 0:
        AgGrid(
            df_display,
            key=f"ro-grid-{_nonce}",
            gridOptions=opts,
            fit_columns_on_grid_load=False,
        )
    else:
        AgGrid(
            df_display,
            key=f"ro-grid-{_nonce}",
            height=grid_h,
            gridOptions=opts,
            fit_columns_on_grid_load=False,
        )

    # Downloads (CSV/XLSX) â€” built from df_display
    with st.container():
        left, mid = st.columns([1, 1])
        with left:
            csv_bytes = df_display.to_csv(index=False).encode("utf-8")
            st.download_button(
                label="Download CSV",
                data=csv_bytes,
                file_name="providers.csv",
                mime="text/csv",
            )
        with mid:
            xlsx_bytes = to_xlsx_bytes(df_display)
            st.download_button(
                label="Download XLSX",
                data=xlsx_bytes,
                file_name="providers.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            )


# === ANCHOR: UI (end) ===


if __name__ == "__main__":
    main()
