# app_admin.py
# -*- coding: utf-8 -*-
from __future__ import annotations

# ---- Streamlit page config MUST be the first Streamlit command ----
import streamlit as st

st.set_page_config(page_title="Providers â€” Admin", page_icon="ðŸ› ï¸", layout="wide")

# ---- Stdlib / typing ----
import os
import re
import csv
from pathlib import Path
from typing import Any, Optional

# ---- Third-party ----
import pandas as pd
import sqlalchemy as sa
from sqlalchemy import text as T
from sqlalchemy.engine import Engine

# =============================
# Configuration
# =============================

# Local SQLite file path (can override via env)
DB_PATH = os.environ.get("PROVIDERS_DB", "providers.db")

# Seed CSV (relative to repo root/file location)
SEED_CSV_REL = "data/providers_seed.csv"

# =============================
# Schema (idempotent DDL)
# =============================

DDL = """
CREATE TABLE IF NOT EXISTS vendors (
  id INTEGER PRIMARY KEY,
  business_name TEXT NOT NULL,
  category TEXT NOT NULL,
  service TEXT NOT NULL,
  contact_name TEXT,
  phone TEXT,
  email TEXT,
  website TEXT,
  address TEXT,
  city TEXT,
  state TEXT DEFAULT 'TX',
  zip TEXT,
  notes TEXT,
  created_at TEXT,
  updated_at TEXT,
  computed_keywords TEXT,
  ckw_locked INTEGER DEFAULT 0,
  ckw_version TEXT
);
CREATE INDEX IF NOT EXISTS idx_vendors_name     ON vendors(business_name COLLATE NOCASE);
CREATE INDEX IF NOT EXISTS idx_vendors_cat      ON vendors(category);
CREATE INDEX IF NOT EXISTS idx_vendors_service  ON vendors(service);
"""


def ensure_schema(engine: Engine) -> None:
    with engine.begin() as cx:
        for stmt in [s.strip() for s in DDL.split(";") if s.strip()]:
            cx.execute(T(stmt))


# =============================
# Engine factory (cached)
# =============================


@st.cache_resource(show_spinner=False)
def get_engine() -> Engine:
    # Single source of truth for the engine
    dsn = f"sqlite:///{DB_PATH}"
    return sa.create_engine(dsn, pool_pre_ping=True)


# Canonical engine alias used everywhere below
_ENGINE: Engine = get_engine()

# Ensure schema exists before any diagnostics/bootstrap
ensure_schema(_ENGINE)

# =============================
# Diagnostics (temporary / safe)
# =============================
try:
    with _ENGINE.connect() as _cx:
        try:
            db_list = _cx.exec_driver_sql("PRAGMA database_list").fetchall()
            db_target = db_list[0][2] if db_list and len(db_list[0]) >= 3 else "n/a"
        except Exception:
            db_target = "n/a"
        vendors_cnt = _cx.exec_driver_sql("SELECT COUNT(*) FROM vendors").scalar()
        if os.getenv("SHOW_STATUS") == "1":
            st.caption(f"DB target: {db_target} | vendors: {int(vendors_cnt or 0)}")
except Exception as e:
    if os.getenv("SHOW_STATUS") == "1":
        st.error(f"DB diagnostics failed: {e}")

# =============================
# Helpers / CRUD
# =============================

def _digits_only(p: Optional[str]) -> Optional[str]:
    if p is None:
        return None
    d = "".join(ch for ch in str(p) if ch.isdigit())
    return d[:10] if d else None

@st.cache_data(show_spinner=False)
def load_all() -> pd.DataFrame:
    with _ENGINE.connect() as cx:
        df = pd.read_sql_query(
            T("""
              SELECT id,business_name,category,service,contact_name,phone,email,website,
                     address,city,state,zip,notes,created_at,updated_at
              FROM vendors
              ORDER BY business_name COLLATE NOCASE ASC
            """),
            cx,
        )
    return df

def insert_row(row: dict[str, Any]) -> int:
    row = dict(row)
    if "phone" in row:
        row["phone"] = _digits_only(row.get("phone"))
    cols = ",".join(row.keys())
    vals = ",".join([f":{k}" for k in row.keys()])
    sql = T(f"INSERT INTO vendors ({cols}) VALUES ({vals})")
    with _ENGINE.begin() as cx:
        cx.execute(sql, row)
        new_id = cx.execute(T("SELECT last_insert_rowid()")).scalar_one()
        return int(new_id)

def update_row(row_id: int, row: dict[str, Any]) -> None:
    row = dict(row)
    if "phone" in row:
        row["phone"] = _digits_only(row.get("phone"))
    sets = ",".join([f"{k}=:{k}" for k in row.keys()])
    row["id"] = row_id
    sql = T(f"UPDATE vendors SET {sets} WHERE id=:id")
    with _ENGINE.begin() as cx:
        cx.execute(sql, row)

def delete_row(row_id: int) -> None:
    with _ENGINE.begin() as cx:
        cx.execute(T("DELETE FROM vendors WHERE id=:id"), {"id": row_id})
# =============================
# One-time CSV bootstrap (guarded)
# =============================


def _bootstrap_from_csv_if_empty(
    engine: Engine, csv_rel_path: str = SEED_CSV_REL
) -> tuple[bool, str]:
    """
    Load providers from CSV only if 'vendors' table exists and is empty.
    Returns (changed, message).
    """
    try:
        with engine.begin() as cx:
            # Verify table presence
            try:
                cx.exec_driver_sql("SELECT 1 FROM vendors LIMIT 1")
            except Exception as e:
                return (False, f"Bootstrap skipped: vendors table not found ({e})")

            cur = int(cx.exec_driver_sql("SELECT COUNT(*) FROM vendors").scalar() or 0)
            if cur > 0:
                return (False, f"Bootstrap skipped: vendors already has {cur} rows")

            csv_path = Path(__file__).parent / csv_rel_path
            if not csv_path.exists():
                return (False, f"Bootstrap failed: CSV not found at {csv_path}")

            with csv_path.open(newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                rows = list(reader)

            if not rows:
                return (False, "Bootstrap skipped: CSV has 0 data rows")

            # Only insert the core columns that are guaranteed to exist
            expected = [
                "business_name",
                "category",
                "service",
                "contact_name",
                "phone",
                "email",
                "website",
                "address",
                "city",
                "state",
                "zip",
                "notes",
            ]
            missing = [c for c in expected if c not in (reader.fieldnames or [])]
            if missing:
                return (False, f"Bootstrap failed: CSV missing columns: {missing}")

            ins_sql = """
                INSERT INTO vendors
                (business_name,category,service,contact_name,phone,email,website,address,city,state,zip,notes)
                VALUES (:business_name,:category,:service,:contact_name,:phone,:email,:website,:address,:city,:state,:zip,:notes)
            """
            for r in rows:
                # Normalize phone to digits only on insert
                r = dict(r)
                r["phone"] = _digits_only(r.get("phone"))
                cx.exec_driver_sql(ins_sql, r)

            new_cnt = int(cx.exec_driver_sql("SELECT COUNT(*) FROM vendors").scalar() or 0)
            return (
                True,
                f"Bootstrap inserted {new_cnt - cur} rows (total now {new_cnt})",
            )
    except Exception as e:
        return (False, f"Bootstrap error: {e}")


changed, msg = _bootstrap_from_csv_if_empty(_ENGINE, SEED_CSV_REL)
if msg:
    st.caption(msg)



def _digits_only(p: Optional[str]) -> Optional[str]:
    if p is None:
        return None
    d = "".join(ch for ch in str(p) if ch.isdigit())
    return d[:10] if d else None


@st.cache_data(show_spinner=False)
def load_all() -> pd.DataFrame:
    with _ENGINE.connect() as cx:
        df = pd.read_sql_query(
            T("""
              SELECT id,business_name,category,service,contact_name,phone,email,website,
                     address,city,state,zip,notes,created_at,updated_at
              FROM vendors
              ORDER BY business_name COLLATE NOCASE ASC
            """),
            cx,
        )
    return df


def insert_row(row: dict[str, Any]) -> int:
    row = dict(row)
    if "phone" in row:
        row["phone"] = _digits_only(row.get("phone"))
    cols = ",".join(row.keys())
    vals = ",".join([f":{k}" for k in row.keys()])
    sql = T(f"INSERT INTO vendors ({cols}) VALUES ({vals})")
    with _ENGINE.begin() as cx:
        cx.execute(sql, row)
        new_id = cx.execute(T("SELECT last_insert_rowid()")).scalar_one()
        return int(new_id)


def update_row(row_id: int, row: dict[str, Any]) -> None:
    row = dict(row)
    if "phone" in row:
        row["phone"] = _digits_only(row.get("phone"))
    sets = ",".join([f"{k}=:{k}" for k in row.keys()])
    row["id"] = row_id
    sql = T(f"UPDATE vendors SET {sets} WHERE id=:id")
    with _ENGINE.begin() as cx:
        cx.execute(sql, row)


def delete_row(row_id: int) -> None:
    with _ENGINE.begin() as cx:
        cx.execute(T("DELETE FROM vendors WHERE id=:id"), {"id": row_id})


# =============================
# UI
# =============================

# Search guard: default to blank so we don't filter out everything on first load
if "q" not in st.session_state or st.session_state.get("q") is None:
    st.session_state["q"] = ""

st.title("Providers â€” Admin (Minimal)")

tabs = st.tabs(["Browse", "Add", "Edit / Delete"])

# -------------------------
# Browse
# -------------------------
with tabs[0]:
    df = load_all()
    left, right = st.columns([3, 1])
    with left:
        q = st.text_input(
            "Search",
            value=st.session_state.get("q", ""),
            placeholder="name, category, service, city, keywordâ€¦",
        ).strip()
        st.session_state["q"] = q
    with right:
        if st.button("Clear"):
            st.session_state["q"] = ""
            q = ""

    vdf = df
    if q:
        qq = re.escape(q)
        mask = (
            df["business_name"].str.contains(qq, case=False, na=False)
            | df["category"].str.contains(qq, case=False, na=False)
            | df["service"].str.contains(qq, case=False, na=False)
            | df["city"].str.contains(qq, case=False, na=False)
            | df["state"].str.contains(qq, case=False, na=False)
        )
        vdf = df[mask]

    if vdf.empty:
        st.info("No matching providers. Tip: try fewer words.")
    else:
        st.caption(f"Rows: {len(vdf)}")
        st.dataframe(vdf, use_container_width=True)
        st.download_button(
            "Download CSV",
            vdf.to_csv(index=False).encode("utf-8"),
            file_name="providers_admin_export.csv",
            mime="text/csv",
        )

# -------------------------
# Add
# -------------------------
with tabs[1]:
    st.subheader("Add Provider")
    with st.form("add_form", clear_on_submit=True):
        c1, c2, c3 = st.columns(3)
        with c1:
            business_name = st.text_input("Business Name *")
            category = st.text_input("Category *")
            service = st.text_input("Service *")
            contact_name = st.text_input("Contact Name")
        with c2:
            phone = st.text_input("Phone (digits only ok)")
            email = st.text_input("Email")
            website = st.text_input("Website")
            address = st.text_input("Address")
        with c3:
            city = st.text_input("City")
            state = st.text_input("State", value="TX")
            zipc = st.text_input("ZIP")
            notes = st.text_area("Notes", height=80)

        submitted = st.form_submit_button("Add")
        if submitted:
            if not business_name or not category or not service:
                st.error("business_name, category, and service are required.")
            else:
                row = dict(
                    business_name=business_name.strip(),
                    category=category.strip(),
                    service=service.strip(),
                    contact_name=contact_name.strip() if contact_name else None,
                    phone=phone.strip() if phone else None,
                    email=email.strip() if email else None,
                    website=website.strip() if website else None,
                    address=address.strip() if address else None,
                    city=city.strip() if city else None,
                    state=state.strip() if state else None,
                    zip=zipc.strip() if zipc else None,
                    notes=notes.strip() if notes else None,
                )
                new_id = insert_row(row)
                st.success(f"Added provider ID {new_id}")
                st.cache_data.clear()

# -------------------------
# Edit / Delete
# -------------------------
with tabs[2]:
    st.subheader("Edit or Delete")
    df = load_all()
    if df.empty:
        st.info("No providers found.")
    else:
        # Simple selector by business name (shows ID)
        df = df.copy()
        df["label"] = df.apply(lambda r: f"[{r['id']}] {r['business_name']}", axis=1)
        selected = st.selectbox("Select a provider:", df["label"].tolist())
        row_id = int(selected.split("]")[0][1:]) if selected else None
        row = df[df["id"] == row_id].iloc[0].to_dict() if row_id else {}

        with st.form("edit_form"):
            c1, c2, c3 = st.columns(3)
            with c1:
                business_name = st.text_input("Business Name *", value=row.get("business_name", ""))
                category = st.text_input("Category *", value=row.get("category", ""))
                service = st.text_input("Service *", value=row.get("service", ""))
                contact_name = st.text_input("Contact Name", value=row.get("contact_name") or "")
            with c2:
                phone = st.text_input("Phone (digits only ok)", value=row.get("phone") or "")
                email = st.text_input("Email", value=row.get("email") or "")
                website = st.text_input("Website", value=row.get("website") or "")
                address = st.text_input("Address", value=row.get("address") or "")
            with c3:
                city = st.text_input("City", value=row.get("city") or "")
                state = st.text_input("State", value=row.get("state") or "TX")
                zipc = st.text_input("ZIP", value=row.get("zip") or "")
                notes = st.text_area("Notes", value=row.get("notes") or "", height=80)

            colA, colB = st.columns([1, 1])
            do_update = colA.form_submit_button("Save Changes")
            do_delete = colB.form_submit_button("Delete", type="secondary")

        if do_update:
            if not business_name or not category or not service:
                st.error("business_name, category, and service are required.")
            else:
                upd = dict(
                    business_name=business_name.strip(),
                    category=category.strip(),
                    service=service.strip(),
                    contact_name=(contact_name or "").strip() or None,
                    phone=(phone or "").strip() or None,
                    email=(email or "").strip() or None,
                    website=(website or "").strip() or None,
                    address=(address or "").strip() or None,
                    city=(city or "").strip() or None,
                    state=(state or "").strip() or None,
                    zip=(zipc or "").strip() or None,
                    notes=(notes or "").strip() or None,
                )
                update_row(row_id, upd)
                st.success(f"Updated provider ID {row_id}")
                st.cache_data.clear()

        if do_delete and row_id is not None:
            delete_row(row_id)
            st.warning(f"Deleted provider ID {row_id}")
            st.cache_data.clear()
